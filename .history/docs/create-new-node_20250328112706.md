## Creating a New Node

This document describes the steps to create a new node in the workflow management system.

### Basic Structure

1. Create a new directory for your node under `src/components/OperationNodes/`
2. Create the following files:
   - `index.tsx` - Main node component
   - `types.ts` - Type definitions
   - `parameterSchemas.ts` - Parameter validation schemas
   - `styles.css` - Component styles
   - `constants.ts` - Default values and configurations

### Parameter Schema Implementation

1. Define parameter types in `types.ts`:
```typescript
import { z } from 'zod';
import { ParameterType } from '../../../types/parameters';

export interface NodeParameter {
  id: string;
  name: string;
  type: ParameterType;
  required?: boolean;
  validation?: {
    min?: number;
    max?: number;
    pattern?: string;
    enum?: string[];
  };
  ui?: {
    widget?: 'slider' | 'select' | 'input' | 'file-upload';
    group?: string;
    step?: number;
    help?: string;
  };
  units?: {
    unit: string;
    displayUnit?: string;
    conversionFactor?: number;
    format?: string;
  };
  constraints?: Array<{
    condition: string;
    message: string;
    severity: 'error' | 'warning' | 'info';
  }>;
  default?: any;
  description?: string;
  category?: string;
}

export interface NodeData {
  id: string;
  type: string;
  parameters: Record<string, NodeParameter>;
  inputs: Array<{
    id: string;
    type: string;
    required?: boolean;
  }>;
  outputs: Array<{
    id: string;
    type: string;
  }>;
}
```

2. Implement parameter schemas in `parameterSchemas.ts`:
```typescript
import { z } from 'zod';
import { createParameterSchema, ParameterValue } from '../../../utils/parameterSchemas';
import { NodeParameter } from './types';

// Define parameter schemas
export const parameterSchemas = {
  parameterName: createParameterSchema<number>({
    id: 'parameterName',
    name: 'Parameter Display Name',
    type: ParameterType.NUMBER,
    required: true,
    validation: {
      min: 0,
      max: 100,
    },
    units: {
      unit: 'base_unit',
      displayUnit: 'display_unit',
      conversionFactor: 1,
      format: '0.00',
    },
    ui: {
      widget: 'slider',
      group: 'Parameter Group',
      step: 1,
      help: 'Help text for the parameter',
    },
    constraints: [
      {
        condition: 'value <= 50',
        message: 'Warning: High value selected',
        severity: 'warning',
      },
    ],
    description: 'Detailed parameter description',
    category: 'parameter_category',
  }),
};

// Export parameter value types
export type ParameterValues = {
  [K in keyof typeof parameterSchemas]: z.infer<typeof parameterSchemas[K]>;
};
```

3. Define constants in `constants.ts`:
```typescript
export const DEFAULT_VALUES = {
  parameterName: 50,
};

export const PARAMETER_GROUPS = {
  GROUP1: 'Basic Parameters',
  GROUP2: 'Advanced Parameters',
} as const;

export const VALIDATION_MESSAGES = {
  REQUIRED: 'This field is required',
  RANGE: 'Value must be between {min} and {max}',
} as const;
```

### Node Component Implementation

1. Create the main node component in `index.tsx`:
```typescript
import React from 'react';
import { Handle, Position } from 'reactflow';
import { useNodeData } from '../../../hooks/useNodeData';
import { parameterSchemas, ParameterValues } from './parameterSchemas';
import { DEFAULT_VALUES } from './constants';
import './styles.css';

interface NodeProps {
  id: string;
  data: any;
}

export const CustomNode: React.FC<NodeProps> = ({ id, data }) => {
  const { parameters, updateParameter } = useNodeData<ParameterValues>(id, {
    defaultValues: DEFAULT_VALUES,
    schemas: parameterSchemas,
  });

  const handleParameterChange = (parameterId: string, value: any) => {
    updateParameter(parameterId, value);
  };

  return (
    <div className="custom-node">
      <Handle type="target" position={Position.Left} />
      
      {/* Node content */}
      <div className="node-content">
        {/* Parameter inputs */}
      </div>

      <Handle type="source" position={Position.Right} />
    </div>
  );
};

export default CustomNode;
```

### Best Practices

1. **Type Safety**
   - Use TypeScript for all components and utilities
   - Define proper interfaces for all data structures
   - Utilize Zod for runtime type validation

2. **Parameter Validation**
   - Define clear validation rules in parameter schemas
   - Include both UI and runtime validation
   - Handle validation errors gracefully

3. **UI/UX**
   - Group related parameters
   - Provide clear help text and tooltips
   - Use appropriate input widgets for different parameter types
   - Show validation feedback immediately

4. **Code Organization**
   - Separate concerns into different files
   - Use constants for repeated values
   - Document complex logic and validation rules

5. **Testing**
   - Write unit tests for parameter validation
   - Test edge cases and error conditions
   - Include integration tests for node behavior

### Node Registration

1. Register the node in `src/components/OperationNodes/index.ts`:
```typescript
import CustomNode from './CustomNode';

export const nodeTypes = {
  customNode: CustomNode,
};
```

2. Add node metadata in `src/config/nodeConfig.ts`:
```typescript
export const nodeConfig = {
  customNode: {
    label: 'Custom Node',
    category: 'Node Category',
    description: 'Node description',
    color: '#someColor',
  },
};
```

### Documentation

1. Add JSDoc comments for all exported functions and types
2. Include examples in the node's README.md
3. Document any special considerations or dependencies
4. Keep track of changes in CHANGELOG.md

### Version Control

1. Create a feature branch for new node development
2. Follow conventional commit messages
3. Update documentation with changes
4. Create detailed PR descriptions

### File Upload Feature Implementation

To add file upload capability to your node:

1. Create a FileUploader component (`src/components/FileUploader.tsx`):
```typescript
import React, { useRef, useEffect, useState } from 'react';
import './FileUploader.css';

interface FileUploaderProps {
  inputId: string;
  nodeId: string;
  onUploadComplete: (result: any) => void;
}

export const FileUploader: React.FC<FileUploaderProps> = ({ inputId, nodeId, onUploadComplete }) => {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [fileName, setFileName] = useState<string | null>(null);

  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    setFileName(file.name);
    const reader = new FileReader();

    reader.onload = (e) => {
      const result = {
        success: true,
        fileName: file.name,
        fileType: file.type,
        data: e.target?.result
      };
      onUploadComplete(result);
    };

    reader.onerror = (error) => {
      console.error('Error reading file:', error);
      setFileName(null);
    };

    reader.readAsText(file);
  };

  const handleUploadClick = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (fileInputRef.current) {
      fileInputRef.current.click();
    }
  };

  return (
    <div className="io-upload-container" onClick={e => e.stopPropagation()}>
      <button 
        className="io-upload-button"
        onClick={handleUploadClick}
        title="Upload data file"
      >
        <svg viewBox="0 0 24 24" width="16" height="16">
          <path fill="currentColor" d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z" />
        </svg>
      </button>
      <input
        type="file"
        ref={fileInputRef}
        style={{ display: 'none' }}
        onChange={handleFileUpload}
        accept=".csv,.xlsx,.json"
        onClick={e => e.stopPropagation()}
      />
      {fileName && (
        <span className="file-name" title={fileName}>
          {fileName}
        </span>
      )}
    </div>
  );
};
```

2. Add FileUploader styles (`src/components/FileUploader.css`):
```css
.io-upload-container {
  display: flex;
  align-items: center;
  gap: 8px;
  position: relative;
  z-index: 1;
}

.io-upload-button {
  width: 28px;
  height: 28px;
  padding: 6px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: white;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
  position: relative;
  z-index: 2;
}

.io-upload-button:hover {
  background: #f5f5f5;
  border-color: #bbb;
}

.io-upload-button svg {
  width: 16px;
  height: 16px;
  color: #666;
}

.file-name {
  font-size: 12px;
  color: #666;
  max-width: 150px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  background: #f5f5f5;
  padding: 4px 8px;
  border-radius: 4px;
}
```

3. Implement file upload handling in your node component:
```typescript
// In your node component
const handleUploadComplete = (inputId: string) => (result: any) => {
  if (data.onDataChange) {
    data.onDataChange({
      ...data,
      inputs: data.inputs?.map(input => 
        input.id === inputId 
          ? { 
              ...input, 
              value: {
                fileName: result.fileName,
                fileType: result.fileType,
                data: result.data
              }
            }
          : input
      )
    });
  }
};

// In your JSX
<div className="io-header">
  <span>{input.label}</span>
  {input.required && <span className="required">*</span>}
  <FileUploader
    inputId={input.id}
    nodeId={data.id}
    onUploadComplete={handleUploadComplete(input.id)}
  />
</div>
```

### Features
The file upload implementation includes:
- Support for CSV, Excel, and JSON files
- Visual feedback with an upload button and file name display
- File content reading and parsing
- Error handling
- Upload status indication
- File name display after successful upload

### Usage
1. Import the FileUploader component
2. Add it to your node's input section
3. Implement the upload complete handler
4. Update the node's data structure to store uploaded file information

### Best Practices
- Always handle file upload errors gracefully
- Provide clear visual feedback to users
- Validate file types before upload
- Keep file size limits in mind
- Use appropriate file parsing based on file type
- Maintain consistent styling with the rest of the application

### Node Properties
Remember to update your node's type definitions to include file-related properties:
```typescript
interface NodeInput {
  id: string;
  label: string;
  required?: boolean;
  value?: {
    fileName: string;
    fileType: string;
    data: any;
  };
}
``` 
