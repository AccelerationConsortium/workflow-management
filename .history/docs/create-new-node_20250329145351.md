# 创建新节点指南

## 1. 基础结构

在 `src/components/OperationNodes/[Category]/[NodeName]/` 下创建以下文件：

```
├── index.tsx                # 主节点组件
├── types.ts                # 类型定义
├── parameterSchemas.ts     # 参数验证模式
├── constants.ts            # 常量定义
├── styles.css             # 样式文件
└── components/            # 子组件目录
    ├── HeaderSection.tsx      # 头部组件
    ├── PrimitiveToggleSection.tsx  # 原语切换组件
    ├── ParameterConfigSection.tsx  # 参数配置组件
    └── StatusIndicator.tsx    # 状态指示器组件
└── hooks/                # 自定义钩子
    └── useNodeData.ts    # 状态管理钩子
```

## 2. 五个维度的最佳实践

### 2.1 状态管理 (⭐⭐⭐⭐⭐)

1. **使用 useReducer 管理复杂状态**
```typescript
// hooks/useNodeData.ts
const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'LOAD_DATA':
      return { /* ... */ };
    case 'UPDATE_PARAMETER':
      return { /* ... */ };
    // ... 其他 action 处理
  }
};
```

2. **清晰的状态更新流程**
- 定义 Action 类型
- 实现 reducer 函数
- 提供状态更新方法
- 支持状态回滚

3. **状态持久化**
- 支持导入/导出配置
- 记录修改历史
- 支持状态重置

### 2.2 交互体验 (⭐⭐⭐⭐½)

1. **错误处理和反馈**
```typescript
// components/StatusIndicator.tsx
const StatusIndicator = ({ errors, status }) => {
  return (
    <div>
      {errors.map(error => (
        <Alert severity="error">{error.message}</Alert>
      ))}
    </div>
  );
};
```

2. **实时验证**
- 参数输入即时验证
- 错误信息清晰展示
- 支持错误定位跳转

3. **视觉反馈**
- 状态变化动画
- 错误高亮提示
- 加载状态指示

### 2.3 结构可维护性 (⭐⭐⭐⭐⭐)

1. **组件分层**
- 主容器组件
- 功能子组件
- 可复用组件

2. **类型定义**
```typescript
// types.ts
export interface NodeData {
  version: string;
  primitives: Record<string, PrimitiveConfig>;
  // ... 其他类型定义
}
```

3. **参数验证**
```typescript
// parameterSchemas.ts
export const createParameterSchema = (def: ParameterDefinition) => {
  return z.object({
    // ... 参数验证规则
  });
};
```

### 2.4 可扩展性 (⭐⭐⭐⭐⭐)

1. **模块化设计**
- 独立的功能模块
- 清晰的接口定义
- 可插拔的组件

2. **配置驱动**
```typescript
// constants.ts
export const CONFIG = {
  features: {
    enableAI: true,
    enablePreview: true,
  },
  validation: {
    // ... 验证规则
  },
};
```

3. **扩展点预留**
- AI 集成接口
- 自定义验证规则
- 模板系统支持

### 2.5 数据持久化 (⭐⭐⭐⭐⭐)

1. **数据格式规范**
```typescript
interface ConfigurationData {
  version: string;
  timestamp: string;
  parameters: Record<string, any>;
  metadata: {
    author: string;
    lastModified: Date;
  };
}
```

2. **版本控制**
- 版本号管理
- 向后兼容
- 迁移支持

3. **导入导出功能**
```typescript
const exportConfig = () => {
  const config = {
    version: currentVersion,
    timestamp: new Date().toISOString(),
    parameters: currentParameters,
  };
  return JSON.stringify(config);
};
```

## 3. 实现检查清单

### 3.1 基础功能
- [ ] 组件目录结构完整
- [ ] 类型定义完善
- [ ] 参数验证规则完整
- [ ] 样式文件规范

### 3.2 状态管理
- [ ] useReducer 实现
- [ ] 状态更新方法
- [ ] 错误处理机制
- [ ] 状态持久化

### 3.3 交互体验
- [ ] 实时验证反馈
- [ ] 错误提示和定位
- [ ] 加载状态展示
- [ ] 动画过渡效果

### 3.4 可维护性
- [ ] 组件职责划分
- [ ] 代码注释完整
- [ ] 类型定义清晰
- [ ] 测试用例覆盖

### 3.5 可扩展性
- [ ] 模块化设计
- [ ] 配置驱动开发
- [ ] 扩展接口预留
- [ ] 文档完善

### 3.6 数据持久化
- [ ] 数据格式规范
- [ ] 版本控制支持
- [ ] 导入导出功能
- [ ] 数据迁移方案

## 4. 注意事项

1. **代码规范**
- 使用 TypeScript 确保类型安全
- 遵循项目代码风格
- 添加必要的注释

2. **性能优化**
- 使用 React.memo 优化渲染
- 实现必要的防抖/节流
- 优化大数据渲染

3. **测试覆盖**
- 单元测试
- 集成测试
- 性能测试

4. **文档维护**
- 更新组件文档
- 记录 API 变更
- 添加使用示例

## Creating a New Node

This document describes the steps to create a new node in the workflow management system.

### Basic Structure

1. Create a new directory for your node under `src/components/OperationNodes/`
2. Create the following files:
   - `index.tsx` - Main node component
   - `types.ts` - Type definitions
   - `parameterSchemas.ts` - Parameter validation schemas
   - `styles.css` - Component styles
   - `constants.ts` - Default values and configurations

### Parameter Schema Implementation

1. Define parameter types in `types.ts`:
```typescript
import { z } from 'zod';
import { ParameterType } from '../../../types/parameters';

export interface NodeParameter {
  id: string;
  name: string;
  type: ParameterType;
  required?: boolean;
  validation?: {
    min?: number;
    max?: number;
    pattern?: string;
    enum?: string[];
  };
  ui?: {
    widget?: 'slider' | 'select' | 'input' | 'file-upload';
    group?: string;
    step?: number;
    help?: string;
  };
  units?: {
    unit: string;
    displayUnit?: string;
    conversionFactor?: number;
    format?: string;
  };
  constraints?: Array<{
    condition: string;
    message: string;
    severity: 'error' | 'warning' | 'info';
  }>;
  default?: any;
  description?: string;
  category?: string;
}

export interface NodeData {
  id: string;
  type: string;
  parameters: Record<string, NodeParameter>;
  inputs: Array<{
    id: string;
    type: string;
    required?: boolean;
  }>;
  outputs: Array<{
    id: string;
    type: string;
  }>;
}
```

2. Implement parameter schemas in `parameterSchemas.ts`:
```typescript
import { z } from 'zod';
import { createParameterSchema, ParameterValue } from '../../../utils/parameterSchemas';
import { NodeParameter } from './types';

// Define parameter schemas
export const parameterSchemas = {
  parameterName: createParameterSchema<number>({
    id: 'parameterName',
    name: 'Parameter Display Name',
    type: ParameterType.NUMBER,
    required: true,
    validation: {
      min: 0,
      max: 100,
    },
    units: {
      unit: 'base_unit',
      displayUnit: 'display_unit',
      conversionFactor: 1,
      format: '0.00',
    },
    ui: {
      widget: 'slider',
      group: 'Parameter Group',
      step: 1,
      help: 'Help text for the parameter',
    },
    constraints: [
      {
        condition: 'value <= 50',
        message: 'Warning: High value selected',
        severity: 'warning',
      },
    ],
    description: 'Detailed parameter description',
    category: 'parameter_category',
  }),
};

// Export parameter value types
export type ParameterValues = {
  [K in keyof typeof parameterSchemas]: z.infer<typeof parameterSchemas[K]>;
};
```

3. Define constants in `constants.ts`:
```typescript
export const DEFAULT_VALUES = {
  parameterName: 50,
};

export const PARAMETER_GROUPS = {
  GROUP1: 'Basic Parameters',
  GROUP2: 'Advanced Parameters',
} as const;

export const VALIDATION_MESSAGES = {
  REQUIRED: 'This field is required',
  RANGE: 'Value must be between {min} and {max}',
} as const;
```

### Node Component Implementation

1. Create the main node component in `index.tsx`:
```typescript
import React from 'react';
import { Handle, Position } from 'reactflow';
import { useNodeData } from '../../../hooks/useNodeData';
import { parameterSchemas, ParameterValues } from './parameterSchemas';
import { DEFAULT_VALUES } from './constants';
import './styles.css';

interface NodeProps {
  id: string;
  data: any;
}

export const CustomNode: React.FC<NodeProps> = ({ id, data }) => {
  const { parameters, updateParameter } = useNodeData<ParameterValues>(id, {
    defaultValues: DEFAULT_VALUES,
    schemas: parameterSchemas,
  });

  const handleParameterChange = (parameterId: string, value: any) => {
    updateParameter(parameterId, value);
  };

  return (
    <div className="custom-node">
      <Handle type="target" position={Position.Left} />
      
      {/* Node content */}
      <div className="node-content">
        {/* Parameter inputs */}
      </div>

      <Handle type="source" position={Position.Right} />
    </div>
  );
};

export default CustomNode;
```

### Best Practices

1. **Type Safety**
   - Use TypeScript for all components and utilities
   - Define proper interfaces for all data structures
   - Utilize Zod for runtime type validation

2. **Parameter Validation**
   - Define clear validation rules in parameter schemas
   - Include both UI and runtime validation
   - Handle validation errors gracefully

3. **UI/UX**
   - Group related parameters
   - Provide clear help text and tooltips
   - Use appropriate input widgets for different parameter types
   - Show validation feedback immediately

4. **Code Organization**
   - Separate concerns into different files
   - Use constants for repeated values
   - Document complex logic and validation rules

5. **Testing**
   - Write unit tests for parameter validation
   - Test edge cases and error conditions
   - Include integration tests for node behavior

### Node Registration

1. Register the node in `src/components/OperationNodes/index.ts`:
```typescript
import CustomNode from './CustomNode';

export const nodeTypes = {
  customNode: CustomNode,
};
```

2. Add node metadata in `src/config/nodeConfig.ts`:
```typescript
export const nodeConfig = {
  customNode: {
    label: 'Custom Node',
    category: 'Node Category',
    description: 'Node description',
    color: '#someColor',
  },
};
```

### Documentation

1. Add JSDoc comments for all exported functions and types
2. Include examples in the node's README.md
3. Document any special considerations or dependencies
4. Keep track of changes in CHANGELOG.md

### Version Control

1. Create a feature branch for new node development
2. Follow conventional commit messages
3. Update documentation with changes
4. Create detailed PR descriptions

### File Upload Feature Implementation

To add file upload capability to your node:

1. Create a FileUploader component (`src/components/FileUploader.tsx`):
```typescript
import React, { useRef, useEffect, useState } from 'react';
import './FileUploader.css';

interface FileUploaderProps {
  inputId: string;
  nodeId: string;
  onUploadComplete: (result: any) => void;
}

export const FileUploader: React.FC<FileUploaderProps> = ({ inputId, nodeId, onUploadComplete }) => {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [fileName, setFileName] = useState<string | null>(null);

  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    setFileName(file.name);
    const reader = new FileReader();

    reader.onload = (e) => {
      const result = {
        success: true,
        fileName: file.name,
        fileType: file.type,
        data: e.target?.result
      };
      onUploadComplete(result);
    };

    reader.onerror = (error) => {
      console.error('Error reading file:', error);
      setFileName(null);
    };

    reader.readAsText(file);
  };

  const handleUploadClick = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (fileInputRef.current) {
      fileInputRef.current.click();
    }
  };

  return (
    <div className="io-upload-container" onClick={e => e.stopPropagation()}>
      <button 
        className="io-upload-button"
        onClick={handleUploadClick}
        title="Upload data file"
      >
        <svg viewBox="0 0 24 24" width="16" height="16">
          <path fill="currentColor" d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z" />
        </svg>
      </button>
      <input
        type="file"
        ref={fileInputRef}
        style={{ display: 'none' }}
        onChange={handleFileUpload}
        accept=".csv,.xlsx,.json"
        onClick={e => e.stopPropagation()}
      />
      {fileName && (
        <span className="file-name" title={fileName}>
          {fileName}
        </span>
      )}
    </div>
  );
};
```

2. Add FileUploader styles (`src/components/FileUploader.css`):
```css
.io-upload-container {
  display: flex;
  align-items: center;
  gap: 8px;
  position: relative;
  z-index: 1;
}

.io-upload-button {
  width: 28px;
  height: 28px;
  padding: 6px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: white;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
  position: relative;
  z-index: 2;
}

.io-upload-button:hover {
  background: #f5f5f5;
  border-color: #bbb;
}

.io-upload-button svg {
  width: 16px;
  height: 16px;
  color: #666;
}

.file-name {
  font-size: 12px;
  color: #666;
  max-width: 150px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  background: #f5f5f5;
  padding: 4px 8px;
  border-radius: 4px;
}
```

3. Implement file upload handling in your node component:
```typescript
// In your node component
const handleUploadComplete = (inputId: string) => (result: any) => {
  if (data.onDataChange) {
    data.onDataChange({
      ...data,
      inputs: data.inputs?.map(input => 
        input.id === inputId 
          ? { 
              ...input, 
              value: {
                fileName: result.fileName,
                fileType: result.fileType,
                data: result.data
              }
            }
          : input
      )
    });
  }
};

// In your JSX
<div className="io-header">
  <span>{input.label}</span>
  {input.required && <span className="required">*</span>}
  <FileUploader
    inputId={input.id}
    nodeId={data.id}
    onUploadComplete={handleUploadComplete(input.id)}
  />
</div>
```

注意：
我们需要在几个地方注册 Activation 节点：
在 src/components/OperationNodes/Medusa/index.tsx 中导出节点
在 src/data/operationNodes.ts 中注册节点定义
在 src/services/validation/parameterDefinitions.ts 中添加参数定义

要把新创建的节点注册为react flow节点


### Features
The file upload implementation includes:
- Support for CSV, Excel, and JSON files
- Visual feedback with an upload button and file name display
- File content reading and parsing
- Error handling
- Upload status indication
- File name display after successful upload

### Usage
1. Import the FileUploader component
2. Add it to your node's input section
3. Implement the upload complete handler
4. Update the node's data structure to store uploaded file information

### Best Practices
- Always handle file upload errors gracefully
- Provide clear visual feedback to users
- Validate file types before upload
- Keep file size limits in mind
- Use appropriate file parsing based on file type
- Maintain consistent styling with the rest of the application

### Node Properties
Remember to update your node's type definitions to include file-related properties:
```typescript
interface NodeInput {
  id: string;
  label: string;
  required?: boolean;
  value?: {
    fileName: string;
    fileType: string;
    data: any;
  };
}
```

## 5. 高级特性实现指南

### 5.1 实验执行上下文（ExecutionContext）

1. **状态定义**
```typescript
// types.ts
export type PrimitiveExecutionStatus = 'idle' | 'running' | 'success' | 'error';

export interface ExecutionContext {
  primitiveId: string;
  status: PrimitiveExecutionStatus;
  startTime?: Date;
  endTime?: Date;
  error?: string;
}

export interface NodeExecutionState {
  status: PrimitiveExecutionStatus;
  contexts: Record<string, ExecutionContext>;
  currentPrimitiveId?: string;
}
```

2. **状态管理集成**
```typescript
// hooks/useNodeData.ts
interface NodeState {
  // ... 其他状态
  execution: NodeExecutionState;
}

const executionReducer = (state: NodeState, action: ExecutionAction): NodeState => {
  switch (action.type) {
    case 'START_PRIMITIVE':
      return {
        ...state,
        execution: {
          ...state.execution,
          contexts: {
            ...state.execution.contexts,
            [action.primitiveId]: {
              primitiveId: action.primitiveId,
              status: 'running',
              startTime: new Date()
            }
          }
        }
      };
    // ... 其他 action 处理
  }
};
```

3. **UI 展示**
```typescript
// components/PrimitiveStatus.tsx
const PrimitiveStatus: React.FC<{context: ExecutionContext}> = ({context}) => {
  const duration = context.endTime && context.startTime
    ? (context.endTime.getTime() - context.startTime.getTime()) / 1000
    : null;

  return (
    <div className="primitive-status">
      <StatusIcon status={context.status} />
      {duration && <span>{duration}s</span>}
      {context.error && <ErrorMessage error={context.error} />}
    </div>
  );
};
```

### 5.2 参数依赖提示系统

1. **规则定义**
```typescript
// types.ts
interface ParameterDependencyRule {
  if: string;  // 条件表达式
  then: {
    param?: string;
    max?: number;
    min?: number;
    disablePrimitive?: string;
    message?: string;
  };
}

interface ParameterConfig {
  // ... 现有参数配置
  dependencies?: ParameterDependencyRule[];
}
```

2. **规则执行器**
```typescript
// utils/ruleEngine.ts
export class RuleEngine {
  evaluateRule(rule: ParameterDependencyRule, context: Record<string, any>): boolean {
    // 实现规则解析和执行
    return eval(this.parseRule(rule.if));
  }

  applyRules(params: Record<string, any>, rules: ParameterDependencyRule[]): void {
    rules.forEach(rule => {
      if (this.evaluateRule(rule, params)) {
        this.applyConstraints(rule.then, params);
      }
    });
  }
}
```

3. **UI 集成**
```typescript
// components/ParameterField.tsx
const ParameterField: React.FC<{param: ParameterConfig}> = ({param}) => {
  const dependencyMessages = useDependencyValidation(param);
  
  return (
    <div className="parameter-field">
      <Input {...inputProps} />
      {dependencyMessages.map(msg => (
        <Tooltip title={msg.detail}>
          <InfoIcon color={msg.severity} />
        </Tooltip>
      ))}
    </div>
  );
};
```

### 5.3 实验模板系统

1. **模板定义**
```typescript
// types.ts
interface NodeTemplate {
  id: string;
  name: string;
  description: string;
  category: string;
  parameters: Record<string, any>;
  primitives: string[];
  metadata: {
    author: string;
    createdAt: Date;
    tags: string[];
  };
}
```

2. **模板管理器**
```typescript
// utils/templateManager.ts
export class TemplateManager {
  async loadTemplate(templateId: string): Promise<NodeTemplate> {
    // 从模板库加载配置
  }

  async saveAsTemplate(config: NodeConfig): Promise<string> {
    // 保存当前配置为新模板
  }
}
```

3. **UI 组件**
```typescript
// components/TemplateSelector.tsx
const TemplateSelector: React.FC = () => {
  const [templates, setTemplates] = useState<NodeTemplate[]>([]);
  
  return (
    <div className="template-selector">
      <Select
        options={templates}
        onChange={handleTemplateSelect}
        groupBy={template => template.category}
        renderOption={template => (
          <TemplateOption
            name={template.name}
            description={template.description}
            metadata={template.metadata}
          />
        )}
      />
    </div>
  );
};
```

### 5.4 Markdown 导出

1. **转换器实现**
```typescript
// utils/markdownExporter.ts
export class MarkdownExporter {
  generateSummary(nodeData: NodeData): string {
    return `
### ${nodeData.name} - Configuration Summary
- Version: ${nodeData.version}
- Created: ${new Date().toISOString().split('T')[0]}
- Primitives Enabled:
${this.formatPrimitives(nodeData.primitives)}
- Validation: ${nodeData.isValid ? '✅ All parameters valid' : '❌ Has errors'}
    `;
  }

  private formatPrimitives(primitives: Record<string, PrimitiveConfig>): string {
    return Object.entries(primitives)
      .filter(([_, p]) => p.enabled)
      .map(([id, p]) => `
  - ${id} ✅
${this.formatParameters(p.parameters)}
      `).join('\n');
  }
}
```

2. **UI 集成**
```typescript
// components/ExportButton.tsx
const ExportButton: React.FC<{data: NodeData}> = ({data}) => {
  const handleExport = async (format: 'json' | 'markdown') => {
    const content = format === 'json'
      ? JSON.stringify(data, null, 2)
      : new MarkdownExporter().generateSummary(data);
      
    await saveToFile(content, `config.${format === 'json' ? 'json' : 'md'}`);
  };

  return (
    <ButtonGroup>
      <Button onClick={() => handleExport('json')}>
        Export JSON
      </Button>
      <Button onClick={() => handleExport('markdown')}>
        Export Markdown
      </Button>
    </ButtonGroup>
  );
};
```

### 5.5 操作日志系统

1. **日志结构**
```typescript
// types.ts
export type LogAction = 
  | { type: 'PARAMETER_CHANGE'; param: string; value: any; }
  | { type: 'PRIMITIVE_TOGGLE'; primitive: string; enabled: boolean; }
  | { type: 'NODE_EXECUTION'; status: ExecutionStatus; }
  | { type: 'TEMPLATE_LOAD'; templateId: string; };

export interface LogEntry {
  id: string;
  timestamp: Date;
  action: LogAction;
  user: string;
  metadata?: Record<string, any>;
}
```

2. **日志管理器**
```typescript
// utils/logManager.ts
export class LogManager {
  private logs: LogEntry[] = [];

  addLog(action: LogAction): void {
    this.logs.push({
      id: generateId(),
      timestamp: new Date(),
      action,
      user: getCurrentUser(),
    });
  }

  getFilteredLogs(filters: LogFilter): LogEntry[] {
    return this.logs.filter(/* ... */);
  }

  exportLogs(format: 'json' | 'csv'): string {
    // 导出日志
  }
}
```

3. **UI 组件**
```typescript
// components/LogViewer.tsx
const LogViewer: React.FC = () => {
  const [logs, setLogs] = useState<LogEntry[]>([]);
  const [filters, setFilters] = useState<LogFilter>({});

  return (
    <div className="log-viewer">
      <LogFilterBar filters={filters} onFilterChange={setFilters} />
      <LogTimeline logs={logs} />
      <LogExportButton onExport={handleExport} />
    </div>
  );
};
```

## 6. 高级特性检查清单

### 6.1 执行上下文
- [ ] 状态定义完整
- [ ] 状态转换逻辑正确
- [ ] UI 实时更新
- [ ] 错误处理完善

### 6.2 参数依赖系统
- [ ] 规则定义清晰
- [ ] 规则执行准确
- [ ] 用户提示友好
- [ ] 性能优化考虑

### 6.3 模板系统
- [ ] 模板格式规范
- [ ] 加载保存功能
- [ ] 版本兼容处理
- [ ] 分类管理支持

### 6.4 Markdown 导出
- [ ] 格式规范统一
- [ ] 内容完整性
- [ ] 样式美观
- [ ] 批量导出支持

### 6.5 日志系统
- [ ] 日志收集完整
- [ ] 查询筛选功能
- [ ] 导出功能支持
- [ ] 存储优化考虑
